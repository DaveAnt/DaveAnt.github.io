<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>基础 on 星空城下无君王</title>
    <link>https://daveant.github.io/tags/%E5%9F%BA%E7%A1%80/</link>
    <description>Recent content in 基础 on 星空城下无君王</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 13 Aug 2020 10:13:34 +0800</lastBuildDate>
    <atom:link href="https://daveant.github.io/tags/%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Unity的Dots技术入门</title>
      <link>https://daveant.github.io/posts/Unity%E7%9A%84Dots%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/</link>
      <pubDate>Thu, 13 Aug 2020 10:13:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/Unity%E7%9A%84Dots%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8/</guid>
      <description>前言 看过Dots技术宣传片,当时确实被震惊到了,脑袋里闪过一句话:时代变了!大人。DOTS是Data</description>
    </item>
    <item>
      <title>编码解码和协议分析</title>
      <link>https://daveant.github.io/posts/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E5%92%8C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 10 Aug 2020 10:13:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E5%92%8C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</guid>
      <description>前言 计算器显示的字符最终存在内存里都是以二进制码形式的,最开始的计算机字符用ASCII编码去存储,A</description>
    </item>
    <item>
      <title>CSharp特性详解</title>
      <link>https://daveant.github.io/posts/CSharp%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 10 Aug 2020 10:03:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/CSharp%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/</guid>
      <description>前言 CSharp的特性(Attribute)是比较难以理解的技术,写代码时通常都要求写注释,为了是让</description>
    </item>
    <item>
      <title>Socket基础知识</title>
      <link>https://daveant.github.io/posts/Socket%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 04 May 2020 15:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/Socket%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>前言 所谓套接字(Socket),就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。套接字</description>
    </item>
    <item>
      <title>CSharp中的多线程</title>
      <link>https://daveant.github.io/posts/CSharp%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Fri, 17 Apr 2020 20:16:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/CSharp%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>1.相关概念 进程 是Windows系统中的基本概念,它包含着运行程序所需要的资源。正在运行的应用程序在</description>
    </item>
    <item>
      <title>坐标空间变换</title>
      <link>https://daveant.github.io/posts/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2/</link>
      <pubDate>Fri, 10 Apr 2020 10:03:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2/</guid>
      <description>前言 这是比较冷门的知识点,为什么需要不同坐标空间？在游戏开发时有很多不同的坐标空间定义,比如模型空间</description>
    </item>
    <item>
      <title>游戏中的数学</title>
      <link>https://daveant.github.io/posts/%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6/</link>
      <pubDate>Fri, 03 Apr 2020 13:03:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6/</guid>
      <description>1.游戏中的矢量 矢量的加减 公式： a+b=(a₁+b₁,a₂+b₂,a₃+b₃) a-b=(a₁-b₁,</description>
    </item>
    <item>
      <title>64位和32位程序的区别</title>
      <link>https://daveant.github.io/posts/64%E4%BD%8D%E5%92%8C32%E4%BD%8D%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 03 Apr 2020 10:03:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/64%E4%BD%8D%E5%92%8C32%E4%BD%8D%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>前言 记得很久以前老大和我说:小明(这里的小明不是课本上的小明)你把这个功能迁移到64位的程序上(ps</description>
    </item>
    <item>
      <title>迭代器模式</title>
      <link>https://daveant.github.io/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 23 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 C#中数据结构都实现了迭代器的功能,具体是如何实现的,接下来就由此篇文章去介绍一下C#是如何实现</description>
    </item>
    <item>
      <title>代理模式</title>
      <link>https://daveant.github.io/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 21 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 代理模式主要是用来对目标对象访问权限的控制,比如游戏商城里购买道具时,通过代理类去判断玩家是否可</description>
    </item>
    <item>
      <title>Unity检视面板重写</title>
      <link>https://daveant.github.io/posts/Unity%E6%A3%80%E8%A7%86%E9%9D%A2%E6%9D%BF%E9%87%8D%E5%86%99/</link>
      <pubDate>Fri, 20 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/Unity%E6%A3%80%E8%A7%86%E9%9D%A2%E6%9D%BF%E9%87%8D%E5%86%99/</guid>
      <description>前言 使用GF框架时,有没有发现很神奇的情况,继承任何模块的辅助器基类脚本(Helper)都会被检视面</description>
    </item>
    <item>
      <title>Unity的Transform小知识点</title>
      <link>https://daveant.github.io/posts/Unity%E7%9A%84Transform%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Fri, 20 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/Unity%E7%9A%84Transform%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      <description>前言 发现Unity的Transform组件有意思的地方,所以这篇文章就先记录一下。 1.抛出问题 先给各</description>
    </item>
    <item>
      <title>单例模式</title>
      <link>https://daveant.github.io/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 20 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 单例模式有二种,饿汉模式和懒汉模式。这里将去实现单例模式的这些例子,然后分析它们的优缺点和使用场</description>
    </item>
    <item>
      <title>原型模式</title>
      <link>https://daveant.github.io/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 19 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 原型模式是用于创建重复的对象,当类里有很多复杂参数的时候,我们可以避免使用拷贝(赋值)构造函数,</description>
    </item>
    <item>
      <title>命令模式</title>
      <link>https://daveant.github.io/posts/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 18 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 命令模式可以实现操作的前进和回滚,经常使用P图软件的用户一定知道软件提供了对操作前进和回滚的功能</description>
    </item>
    <item>
      <title>备忘录模式</title>
      <link>https://daveant.github.io/posts/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 17 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 不知诸君有没有看过在下写的命令模式实现操作前进和回滚的文章,其实备忘录模式的主要目的也是这个,但</description>
    </item>
    <item>
      <title>外观模式</title>
      <link>https://daveant.github.io/posts/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 16 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 外观模式就相当于服务员,比如去餐厅吃饭时,服务员首先会给你菜单让你点菜,给你端茶递菜,然后清理桌</description>
    </item>
    <item>
      <title>工厂模式</title>
      <link>https://daveant.github.io/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 15 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>1.简单工厂模式 简单工厂模式的缺点,把矛盾集中在简单工厂类中,使工厂类高耦合,而且进行修改和添加的时</description>
    </item>
    <item>
      <title>建造模式</title>
      <link>https://daveant.github.io/posts/%E5%BB%BA%E9%80%A0%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 14 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E5%BB%BA%E9%80%A0%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 最近在写一个功能考虑到不同配置去自动调整渲染,以适应不同机型或者是让用户自己去选择高,中,低的渲</description>
    </item>
    <item>
      <title>MVC模式</title>
      <link>https://daveant.github.io/posts/MVC%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 13 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/MVC%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 MVC模式是视图层、控制层、模型层代码进行分层开发,视图层只关心UI的变化,控制层获取模型对象,</description>
    </item>
    <item>
      <title>中介者模式</title>
      <link>https://daveant.github.io/posts/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 13 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 当看到一个类有很多复杂的对象引用和相互调用时,导致代码变得很乱,这个时候就可以使用中介者模式去解</description>
    </item>
    <item>
      <title>享元模式</title>
      <link>https://daveant.github.io/posts/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 13 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 看到享元模式,想到了在工作时写的地图编辑器就可以使用此模式去优化一下内存,享元模式主要减少创建对</description>
    </item>
    <item>
      <title>桥接模式</title>
      <link>https://daveant.github.io/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 13 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 这篇文章介绍Untiy中一套动作通用多个模型原理和画图软件一些模块原理,桥接模式就这样登场了。 1</description>
    </item>
    <item>
      <title>模板方法模式</title>
      <link>https://daveant.github.io/posts/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 12 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 模板方法模式和空对象模式刚刚相反,是经常使用的模式,可能经常用到也不知道它原来叫模板方法模式。 1</description>
    </item>
    <item>
      <title>状态模式</title>
      <link>https://daveant.github.io/posts/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 11 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 当类的某个属性发生改变时允许改变其内部的行为,可以减少分支语言和选择开关的集中。 1.Unity动</description>
    </item>
    <item>
      <title>空对象模式</title>
      <link>https://daveant.github.io/posts/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 10 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E7%A9%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 空对象模式基本很少用到,空对象去取代空引用,主要目的是当数据是空引用时提供一种默认的处理方式。 1</description>
    </item>
    <item>
      <title>策略模式</title>
      <link>https://daveant.github.io/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 09 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 不知道各位有没有玩过三国杀,这里将用策略模式去模拟三国杀游戏,各位看完一定会感觉很生动形象,最后</description>
    </item>
    <item>
      <title>组合模式</title>
      <link>https://daveant.github.io/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 08 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 组合模式称为整体部分模式,主要是表现对象层次具备整体和部分,呈树形结构,且要求具备统一行为。 1.</description>
    </item>
    <item>
      <title>装饰器模式</title>
      <link>https://daveant.github.io/posts/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 07 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 装饰器模式可以动态的给对象添加额外的职责,增加新的功能,思考一下和对象适配器的模式到底存在那些区</description>
    </item>
    <item>
      <title>观察者模式</title>
      <link>https://daveant.github.io/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 这篇文章讲述消息监听方案的发展史,来阐述观察者模式的优点。本篇文章的故事纯属虚构,如有雷同只是巧</description>
    </item>
    <item>
      <title>解释器模式</title>
      <link>https://daveant.github.io/posts/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 05 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 在游戏中需要生成json的存档文件时(比如游戏中音效大小的存储),就可以使用解释器模式来生成此文</description>
    </item>
    <item>
      <title>访问者模式</title>
      <link>https://daveant.github.io/posts/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 04 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 如果对象中的数据是稳定不变,但访问数据方式可能易变的或需扩展的。可以使用访问者模式,主要是为了对</description>
    </item>
    <item>
      <title>责任链模式</title>
      <link>https://daveant.github.io/posts/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 03 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 不知道各位有没有看过在下写的过滤器模式文章,这篇文章主要是用责任链模式去重构之前文章中组合过滤器</description>
    </item>
    <item>
      <title>过滤器模式</title>
      <link>https://daveant.github.io/posts/%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 02 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 网上对过滤器的解释已经很多了,而且这个模式的概念理解起来不算很难,但是发现网上提供的Demo代码</description>
    </item>
    <item>
      <title>适配器模式</title>
      <link>https://daveant.github.io/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 01 Mar 2020 23:23:34 +0800</pubDate>
      <guid>https://daveant.github.io/posts/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>前言 适配器模式从实现方式上分为三种,类适配器和对象适配器还有缺省适配器,它们区别在于实现方式和实际使</description>
    </item>
  </channel>
</rss>
